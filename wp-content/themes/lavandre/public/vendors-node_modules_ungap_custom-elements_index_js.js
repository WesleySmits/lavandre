(self["webpackChunklavandre"] = self["webpackChunklavandre"] || []).push([["vendors-node_modules_ungap_custom-elements_index_js"],{

/***/ "./node_modules/@ungap/custom-elements/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@ungap/custom-elements/index.js ***!
  \******************************************************/
/***/ (function() {

/*! (c) Andrea Giammarchi @webreflection ISC */
(function () {
  'use strict';

  var Lie = typeof Promise === 'function' ? Promise : function (fn) {
    var queue = [],
        resolved = 0,
        value;
    fn(function ($) {
      value = $;
      resolved = 1;
      queue.splice(0).forEach(then);
    });
    return {
      then: then
    };

    function then(fn) {
      return resolved ? setTimeout(fn, 0, value) : queue.push(fn), this;
    }
  };

  var attributesObserver = (function (whenDefined, MutationObserver) {
    var attributeChanged = function attributeChanged(records) {
      for (var i = 0, length = records.length; i < length; i++) {
        dispatch(records[i]);
      }
    };

    var dispatch = function dispatch(_ref) {
      var target = _ref.target,
          attributeName = _ref.attributeName,
          oldValue = _ref.oldValue;
      target.attributeChangedCallback(attributeName, oldValue, target.getAttribute(attributeName));
    };

    return function (target, is) {
      var attributeFilter = target.constructor.observedAttributes;

      if (attributeFilter) {
        whenDefined(is).then(function () {
          new MutationObserver(attributeChanged).observe(target, {
            attributes: true,
            attributeOldValue: true,
            attributeFilter: attributeFilter
          });

          for (var i = 0, length = attributeFilter.length; i < length; i++) {
            if (target.hasAttribute(attributeFilter[i])) dispatch({
              target: target,
              attributeName: attributeFilter[i],
              oldValue: null
            });
          }
        });
      }

      return target;
    };
  });

  var TRUE = true,
      FALSE = false;
  var QSA$1 = 'querySelectorAll';

  function add(node) {
    this.observe(node, {
      subtree: TRUE,
      childList: TRUE
    });
  }
  /**
   * Start observing a generic document or root element.
   * @param {Function} callback triggered per each dis/connected node
   * @param {Element?} root by default, the global document to observe
   * @param {Function?} MO by default, the global MutationObserver
   * @returns {MutationObserver}
   */


  var notify = function notify(callback, root, MO) {
    var loop = function loop(nodes, added, removed, connected, pass) {
      for (var i = 0, length = nodes.length; i < length; i++) {
        var node = nodes[i];

        if (pass || QSA$1 in node) {
          if (connected) {
            if (!added.has(node)) {
              added.add(node);
              removed["delete"](node);
              callback(node, connected);
            }
          } else if (!removed.has(node)) {
            removed.add(node);
            added["delete"](node);
            callback(node, connected);
          }

          if (!pass) loop(node[QSA$1]('*'), added, removed, connected, TRUE);
        }
      }
    };

    var observer = new (MO || MutationObserver)(function (records) {
      for (var added = new Set(), removed = new Set(), i = 0, length = records.length; i < length; i++) {
        var _records$i = records[i],
            addedNodes = _records$i.addedNodes,
            removedNodes = _records$i.removedNodes;
        loop(removedNodes, added, removed, FALSE, FALSE);
        loop(addedNodes, added, removed, TRUE, FALSE);
      }
    });
    observer.add = add;
    observer.add(root || document);
    return observer;
  };

  var QSA = 'querySelectorAll';
  var _self$1 = self,
      document$2 = _self$1.document,
      Element$1 = _self$1.Element,
      MutationObserver$2 = _self$1.MutationObserver,
      Set$2 = _self$1.Set,
      WeakMap$1 = _self$1.WeakMap;

  var elements = function elements(element) {
    return QSA in element;
  };

  var filter = [].filter;
  var qsaObserver = (function (options) {
    var live = new WeakMap$1();

    var drop = function drop(elements) {
      for (var i = 0, length = elements.length; i < length; i++) {
        live["delete"](elements[i]);
      }
    };

    var flush = function flush() {
      var records = observer.takeRecords();

      for (var i = 0, length = records.length; i < length; i++) {
        parse(filter.call(records[i].removedNodes, elements), false);
        parse(filter.call(records[i].addedNodes, elements), true);
      }
    };

    var matches = function matches(element) {
      return element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
    };

    var notifier = function notifier(element, connected) {
      var selectors;

      if (connected) {
        for (var q, m = matches(element), i = 0, length = query.length; i < length; i++) {
          if (m.call(element, q = query[i])) {
            if (!live.has(element)) live.set(element, new Set$2());
            selectors = live.get(element);

            if (!selectors.has(q)) {
              selectors.add(q);
              options.handle(element, connected, q);
            }
          }
        }
      } else if (live.has(element)) {
        selectors = live.get(element);
        live["delete"](element);
        selectors.forEach(function (q) {
          options.handle(element, connected, q);
        });
      }
    };

    var parse = function parse(elements) {
      var connected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      for (var i = 0, length = elements.length; i < length; i++) {
        notifier(elements[i], connected);
      }
    };

    var query = options.query;
    var root = options.root || document$2;
    var observer = notify(notifier, root, MutationObserver$2);
    var attachShadow = Element$1.prototype.attachShadow;
    if (attachShadow) Element$1.prototype.attachShadow = function (init) {
      var shadowRoot = attachShadow.call(this, init);
      observer.add(shadowRoot);
      return shadowRoot;
    };
    if (query.length) parse(root[QSA](query));
    return {
      drop: drop,
      flush: flush,
      observer: observer,
      parse: parse
    };
  });

  var _self = self,
      document$1 = _self.document,
      Map = _self.Map,
      MutationObserver$1 = _self.MutationObserver,
      Object$1 = _self.Object,
      Set$1 = _self.Set,
      WeakMap = _self.WeakMap,
      Element = _self.Element,
      HTMLElement = _self.HTMLElement,
      Node = _self.Node,
      Error = _self.Error,
      TypeError = _self.TypeError,
      Reflect = _self.Reflect;
  var Promise$1 = self.Promise || Lie;
  var defineProperty = Object$1.defineProperty,
      keys = Object$1.keys,
      getOwnPropertyNames = Object$1.getOwnPropertyNames,
      setPrototypeOf = Object$1.setPrototypeOf;
  var legacy = !self.customElements;

  var expando = function expando(element) {
    var key = keys(element);
    var value = [];
    var length = key.length;

    for (var i = 0; i < length; i++) {
      value[i] = element[key[i]];
      delete element[key[i]];
    }

    return function () {
      for (var _i = 0; _i < length; _i++) {
        element[key[_i]] = value[_i];
      }
    };
  };

  if (legacy) {
    var HTMLBuiltIn = function HTMLBuiltIn() {
      var constructor = this.constructor;
      if (!classes.has(constructor)) throw new TypeError('Illegal constructor');
      var is = classes.get(constructor);
      if (override) return augment(override, is);
      var element = createElement.call(document$1, is);
      return augment(setPrototypeOf(element, constructor.prototype), is);
    };

    var createElement = document$1.createElement;
    var classes = new Map();
    var defined = new Map();
    var prototypes = new Map();
    var registry = new Map();
    var query = [];

    var handle = function handle(element, connected, selector) {
      var proto = prototypes.get(selector);

      if (connected && !proto.isPrototypeOf(element)) {
        var redefine = expando(element);
        override = setPrototypeOf(element, proto);

        try {
          new proto.constructor();
        } finally {
          override = null;
          redefine();
        }
      }

      var method = "".concat(connected ? '' : 'dis', "connectedCallback");
      if (method in proto) element[method]();
    };

    var _qsaObserver = qsaObserver({
      query: query,
      handle: handle
    }),
        parse = _qsaObserver.parse;

    var override = null;

    var whenDefined = function whenDefined(name) {
      if (!defined.has(name)) {
        var _,
            $ = new Lie(function ($) {
          _ = $;
        });

        defined.set(name, {
          $: $,
          _: _
        });
      }

      return defined.get(name).$;
    };

    var augment = attributesObserver(whenDefined, MutationObserver$1);
    defineProperty(self, 'customElements', {
      configurable: true,
      value: {
        define: function define(is, Class) {
          if (registry.has(is)) throw new Error("the name \"".concat(is, "\" has already been used with this registry"));
          classes.set(Class, is);
          prototypes.set(is, Class.prototype);
          registry.set(is, Class);
          query.push(is);
          whenDefined(is).then(function () {
            parse(document$1.querySelectorAll(is));
          });

          defined.get(is)._(Class);
        },
        get: function get(is) {
          return registry.get(is);
        },
        whenDefined: whenDefined
      }
    });
    defineProperty(HTMLBuiltIn.prototype = HTMLElement.prototype, 'constructor', {
      value: HTMLBuiltIn
    });
    defineProperty(self, 'HTMLElement', {
      configurable: true,
      value: HTMLBuiltIn
    });
    defineProperty(document$1, 'createElement', {
      configurable: true,
      value: function value(name, options) {
        var is = options && options.is;
        var Class = is ? registry.get(is) : registry.get(name);
        return Class ? new Class() : createElement.call(document$1, name);
      }
    }); // in case ShadowDOM is used through a polyfill, to avoid issues
    // with builtin extends within shadow roots

    if (!('isConnected' in Node.prototype)) defineProperty(Node.prototype, 'isConnected', {
      configurable: true,
      get: function get() {
        return !(this.ownerDocument.compareDocumentPosition(this) & this.DOCUMENT_POSITION_DISCONNECTED);
      }
    });
  } else {
    try {
      var LI = function LI() {
        return self.Reflect.construct(HTMLLIElement, [], LI);
      };

      LI.prototype = HTMLLIElement.prototype;
      var is = 'extends-li';
      self.customElements.define('extends-li', LI, {
        'extends': 'li'
      });
      legacy = document$1.createElement('li', {
        is: is
      }).outerHTML.indexOf(is) < 0;
      var _self$customElements = self.customElements,
          get = _self$customElements.get,
          _whenDefined = _self$customElements.whenDefined;
      defineProperty(self.customElements, 'whenDefined', {
        configurable: true,
        value: function value(is) {
          var _this = this;

          return _whenDefined.call(this, is).then(function (Class) {
            return Class || get.call(_this, is);
          });
        }
      });
    } catch (o_O) {
      legacy = !legacy;
    }
  }

  if (legacy) {
    var parseShadow = function parseShadow(element) {
      var root = shadowRoots.get(element);

      _parse(root.querySelectorAll(this), element.isConnected);
    };

    var customElements = self.customElements;
    var attachShadow = Element.prototype.attachShadow;
    var _createElement = document$1.createElement;
    var define = customElements.define,
        _get = customElements.get;

    var _ref = Reflect || {
      construct: function construct(HTMLElement) {
        return HTMLElement.call(this);
      }
    },
        construct = _ref.construct;

    var shadowRoots = new WeakMap();
    var shadows = new Set$1();

    var _classes = new Map();

    var _defined = new Map();

    var _prototypes = new Map();

    var _registry = new Map();

    var shadowed = [];
    var _query = [];

    var getCE = function getCE(is) {
      return _registry.get(is) || _get.call(customElements, is);
    };

    var _handle = function _handle(element, connected, selector) {
      var proto = _prototypes.get(selector);

      if (connected && !proto.isPrototypeOf(element)) {
        var redefine = expando(element);
        _override = setPrototypeOf(element, proto);

        try {
          new proto.constructor();
        } finally {
          _override = null;
          redefine();
        }
      }

      var method = "".concat(connected ? '' : 'dis', "connectedCallback");
      if (method in proto) element[method]();
    };

    var _qsaObserver2 = qsaObserver({
      query: _query,
      handle: _handle
    }),
        _parse = _qsaObserver2.parse;

    var _qsaObserver3 = qsaObserver({
      query: shadowed,
      handle: function handle(element, connected) {
        if (shadowRoots.has(element)) {
          if (connected) shadows.add(element);else shadows["delete"](element);
          if (_query.length) parseShadow.call(_query, element);
        }
      }
    }),
        parseShadowed = _qsaObserver3.parse;

    var _whenDefined2 = function _whenDefined2(name) {
      if (!_defined.has(name)) {
        var _,
            $ = new Promise$1(function ($) {
          _ = $;
        });

        _defined.set(name, {
          $: $,
          _: _
        });
      }

      return _defined.get(name).$;
    };

    var _augment = attributesObserver(_whenDefined2, MutationObserver$1);

    var _override = null;
    getOwnPropertyNames(self).filter(function (k) {
      return /^HTML/.test(k);
    }).forEach(function (k) {
      var HTMLElement = self[k];

      function HTMLBuiltIn() {
        var constructor = this.constructor;
        if (!_classes.has(constructor)) throw new TypeError('Illegal constructor');

        var _classes$get = _classes.get(constructor),
            is = _classes$get.is,
            tag = _classes$get.tag;

        if (is) {
          if (_override) return _augment(_override, is);

          var element = _createElement.call(document$1, tag);

          element.setAttribute('is', is);
          return _augment(setPrototypeOf(element, constructor.prototype), is);
        } else return construct.call(this, HTMLElement, [], constructor);
      }


      defineProperty(HTMLBuiltIn.prototype = HTMLElement.prototype, 'constructor', {
        value: HTMLBuiltIn
      });
      defineProperty(self, k, {
        value: HTMLBuiltIn
      });
    });
    defineProperty(document$1, 'createElement', {
      configurable: true,
      value: function value(name, options) {
        var is = options && options.is;

        if (is) {
          var Class = _registry.get(is);

          if (Class && _classes.get(Class).tag === name) return new Class();
        }

        var element = _createElement.call(document$1, name);

        if (is) element.setAttribute('is', is);
        return element;
      }
    });
    if (attachShadow) Element.prototype.attachShadow = function (init) {
      var root = attachShadow.call(this, init);
      shadowRoots.set(this, root);
      return root;
    };
    defineProperty(customElements, 'get', {
      configurable: true,
      value: getCE
    });
    defineProperty(customElements, 'whenDefined', {
      configurable: true,
      value: _whenDefined2
    });
    defineProperty(customElements, 'define', {
      configurable: true,
      value: function value(is, Class, options) {
        if (getCE(is)) throw new Error("'".concat(is, "' has already been defined as a custom element"));
        var selector;
        var tag = options && options["extends"];

        _classes.set(Class, tag ? {
          is: is,
          tag: tag
        } : {
          is: '',
          tag: is
        });

        if (tag) {
          selector = "".concat(tag, "[is=\"").concat(is, "\"]");

          _prototypes.set(selector, Class.prototype);

          _registry.set(is, Class);

          _query.push(selector);
        } else {
          define.apply(customElements, arguments);
          shadowed.push(selector = is);
        }

        _whenDefined2(is).then(function () {
          if (tag) {
            _parse(document$1.querySelectorAll(selector));

            shadows.forEach(parseShadow, [selector]);
          } else parseShadowed(document$1.querySelectorAll(selector));
        });

        _defined.get(is)._(Class);
      }
    });
  }

}());


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdW5nYXBfY3VzdG9tLWVsZW1lbnRzX2luZGV4X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWCwyREFBMkQsWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFdBQVc7QUFDeEIsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RkFBdUYsWUFBWTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLFlBQVk7QUFDcEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGF2YW5kcmUvLi9ub2RlX21vZHVsZXMvQHVuZ2FwL2N1c3RvbS1lbGVtZW50cy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKGMpIEFuZHJlYSBHaWFtbWFyY2hpIEB3ZWJyZWZsZWN0aW9uIElTQyAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBMaWUgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyA/IFByb21pc2UgOiBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgcXVldWUgPSBbXSxcbiAgICAgICAgcmVzb2x2ZWQgPSAwLFxuICAgICAgICB2YWx1ZTtcbiAgICBmbihmdW5jdGlvbiAoJCkge1xuICAgICAgdmFsdWUgPSAkO1xuICAgICAgcmVzb2x2ZWQgPSAxO1xuICAgICAgcXVldWUuc3BsaWNlKDApLmZvckVhY2godGhlbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRoZW46IHRoZW5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdGhlbihmbikge1xuICAgICAgcmV0dXJuIHJlc29sdmVkID8gc2V0VGltZW91dChmbiwgMCwgdmFsdWUpIDogcXVldWUucHVzaChmbiksIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhdHRyaWJ1dGVzT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKHdoZW5EZWZpbmVkLCBNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgdmFyIGF0dHJpYnV0ZUNoYW5nZWQgPSBmdW5jdGlvbiBhdHRyaWJ1dGVDaGFuZ2VkKHJlY29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSByZWNvcmRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRpc3BhdGNoKHJlY29yZHNbaV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaChfcmVmKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWYuYXR0cmlidXRlTmFtZSxcbiAgICAgICAgICBvbGRWYWx1ZSA9IF9yZWYub2xkVmFsdWU7XG4gICAgICB0YXJnZXQuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlLCB0YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGlzKSB7XG4gICAgICB2YXIgYXR0cmlidXRlRmlsdGVyID0gdGFyZ2V0LmNvbnN0cnVjdG9yLm9ic2VydmVkQXR0cmlidXRlcztcblxuICAgICAgaWYgKGF0dHJpYnV0ZUZpbHRlcikge1xuICAgICAgICB3aGVuRGVmaW5lZChpcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoYXR0cmlidXRlQ2hhbmdlZCkub2JzZXJ2ZSh0YXJnZXQsIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogYXR0cmlidXRlRmlsdGVyXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXR0cmlidXRlRmlsdGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVGaWx0ZXJbaV0pKSBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiBhdHRyaWJ1dGVGaWx0ZXJbaV0sXG4gICAgICAgICAgICAgIG9sZFZhbHVlOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gIH0pO1xuXG4gIHZhciBUUlVFID0gdHJ1ZSxcbiAgICAgIEZBTFNFID0gZmFsc2U7XG4gIHZhciBRU0EkMSA9ICdxdWVyeVNlbGVjdG9yQWxsJztcblxuICBmdW5jdGlvbiBhZGQobm9kZSkge1xuICAgIHRoaXMub2JzZXJ2ZShub2RlLCB7XG4gICAgICBzdWJ0cmVlOiBUUlVFLFxuICAgICAgY2hpbGRMaXN0OiBUUlVFXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IG9ic2VydmluZyBhIGdlbmVyaWMgZG9jdW1lbnQgb3Igcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0cmlnZ2VyZWQgcGVyIGVhY2ggZGlzL2Nvbm5lY3RlZCBub2RlXG4gICAqIEBwYXJhbSB7RWxlbWVudD99IHJvb3QgYnkgZGVmYXVsdCwgdGhlIGdsb2JhbCBkb2N1bWVudCB0byBvYnNlcnZlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb24/fSBNTyBieSBkZWZhdWx0LCB0aGUgZ2xvYmFsIE11dGF0aW9uT2JzZXJ2ZXJcbiAgICogQHJldHVybnMge011dGF0aW9uT2JzZXJ2ZXJ9XG4gICAqL1xuXG5cbiAgdmFyIG5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeShjYWxsYmFjaywgcm9vdCwgTU8pIHtcbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uIGxvb3Aobm9kZXMsIGFkZGVkLCByZW1vdmVkLCBjb25uZWN0ZWQsIHBhc3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgIGlmIChwYXNzIHx8IFFTQSQxIGluIG5vZGUpIHtcbiAgICAgICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBpZiAoIWFkZGVkLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICBhZGRlZC5hZGQobm9kZSk7XG4gICAgICAgICAgICAgIHJlbW92ZWRbXCJkZWxldGVcIl0obm9kZSk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUsIGNvbm5lY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghcmVtb3ZlZC5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgIHJlbW92ZWQuYWRkKG5vZGUpO1xuICAgICAgICAgICAgYWRkZWRbXCJkZWxldGVcIl0obm9kZSk7XG4gICAgICAgICAgICBjYWxsYmFjayhub2RlLCBjb25uZWN0ZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghcGFzcykgbG9vcChub2RlW1FTQSQxXSgnKicpLCBhZGRlZCwgcmVtb3ZlZCwgY29ubmVjdGVkLCBUUlVFKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgKE1PIHx8IE11dGF0aW9uT2JzZXJ2ZXIpKGZ1bmN0aW9uIChyZWNvcmRzKSB7XG4gICAgICBmb3IgKHZhciBhZGRlZCA9IG5ldyBTZXQoKSwgcmVtb3ZlZCA9IG5ldyBTZXQoKSwgaSA9IDAsIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9yZWNvcmRzJGkgPSByZWNvcmRzW2ldLFxuICAgICAgICAgICAgYWRkZWROb2RlcyA9IF9yZWNvcmRzJGkuYWRkZWROb2RlcyxcbiAgICAgICAgICAgIHJlbW92ZWROb2RlcyA9IF9yZWNvcmRzJGkucmVtb3ZlZE5vZGVzO1xuICAgICAgICBsb29wKHJlbW92ZWROb2RlcywgYWRkZWQsIHJlbW92ZWQsIEZBTFNFLCBGQUxTRSk7XG4gICAgICAgIGxvb3AoYWRkZWROb2RlcywgYWRkZWQsIHJlbW92ZWQsIFRSVUUsIEZBTFNFKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5hZGQgPSBhZGQ7XG4gICAgb2JzZXJ2ZXIuYWRkKHJvb3QgfHwgZG9jdW1lbnQpO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbiAgfTtcblxuICB2YXIgUVNBID0gJ3F1ZXJ5U2VsZWN0b3JBbGwnO1xuICB2YXIgX3NlbGYkMSA9IHNlbGYsXG4gICAgICBkb2N1bWVudCQyID0gX3NlbGYkMS5kb2N1bWVudCxcbiAgICAgIEVsZW1lbnQkMSA9IF9zZWxmJDEuRWxlbWVudCxcbiAgICAgIE11dGF0aW9uT2JzZXJ2ZXIkMiA9IF9zZWxmJDEuTXV0YXRpb25PYnNlcnZlcixcbiAgICAgIFNldCQyID0gX3NlbGYkMS5TZXQsXG4gICAgICBXZWFrTWFwJDEgPSBfc2VsZiQxLldlYWtNYXA7XG5cbiAgdmFyIGVsZW1lbnRzID0gZnVuY3Rpb24gZWxlbWVudHMoZWxlbWVudCkge1xuICAgIHJldHVybiBRU0EgaW4gZWxlbWVudDtcbiAgfTtcblxuICB2YXIgZmlsdGVyID0gW10uZmlsdGVyO1xuICB2YXIgcXNhT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgbGl2ZSA9IG5ldyBXZWFrTWFwJDEoKTtcblxuICAgIHZhciBkcm9wID0gZnVuY3Rpb24gZHJvcChlbGVtZW50cykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpdmVbXCJkZWxldGVcIl0oZWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgIHZhciByZWNvcmRzID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFyc2UoZmlsdGVyLmNhbGwocmVjb3Jkc1tpXS5yZW1vdmVkTm9kZXMsIGVsZW1lbnRzKSwgZmFsc2UpO1xuICAgICAgICBwYXJzZShmaWx0ZXIuY2FsbChyZWNvcmRzW2ldLmFkZGVkTm9kZXMsIGVsZW1lbnRzKSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBtYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcyhlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzIHx8IGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3I7XG4gICAgfTtcblxuICAgIHZhciBub3RpZmllciA9IGZ1bmN0aW9uIG5vdGlmaWVyKGVsZW1lbnQsIGNvbm5lY3RlZCkge1xuICAgICAgdmFyIHNlbGVjdG9ycztcblxuICAgICAgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICBmb3IgKHZhciBxLCBtID0gbWF0Y2hlcyhlbGVtZW50KSwgaSA9IDAsIGxlbmd0aCA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG0uY2FsbChlbGVtZW50LCBxID0gcXVlcnlbaV0pKSB7XG4gICAgICAgICAgICBpZiAoIWxpdmUuaGFzKGVsZW1lbnQpKSBsaXZlLnNldChlbGVtZW50LCBuZXcgU2V0JDIoKSk7XG4gICAgICAgICAgICBzZWxlY3RvcnMgPSBsaXZlLmdldChlbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKCFzZWxlY3RvcnMuaGFzKHEpKSB7XG4gICAgICAgICAgICAgIHNlbGVjdG9ycy5hZGQocSk7XG4gICAgICAgICAgICAgIG9wdGlvbnMuaGFuZGxlKGVsZW1lbnQsIGNvbm5lY3RlZCwgcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxpdmUuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIHNlbGVjdG9ycyA9IGxpdmUuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBsaXZlW1wiZGVsZXRlXCJdKGVsZW1lbnQpO1xuICAgICAgICBzZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAocSkge1xuICAgICAgICAgIG9wdGlvbnMuaGFuZGxlKGVsZW1lbnQsIGNvbm5lY3RlZCwgcSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcGFyc2UgPSBmdW5jdGlvbiBwYXJzZShlbGVtZW50cykge1xuICAgICAgdmFyIGNvbm5lY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vdGlmaWVyKGVsZW1lbnRzW2ldLCBjb25uZWN0ZWQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcXVlcnkgPSBvcHRpb25zLnF1ZXJ5O1xuICAgIHZhciByb290ID0gb3B0aW9ucy5yb290IHx8IGRvY3VtZW50JDI7XG4gICAgdmFyIG9ic2VydmVyID0gbm90aWZ5KG5vdGlmaWVyLCByb290LCBNdXRhdGlvbk9ic2VydmVyJDIpO1xuICAgIHZhciBhdHRhY2hTaGFkb3cgPSBFbGVtZW50JDEucHJvdG90eXBlLmF0dGFjaFNoYWRvdztcbiAgICBpZiAoYXR0YWNoU2hhZG93KSBFbGVtZW50JDEucHJvdG90eXBlLmF0dGFjaFNoYWRvdyA9IGZ1bmN0aW9uIChpbml0KSB7XG4gICAgICB2YXIgc2hhZG93Um9vdCA9IGF0dGFjaFNoYWRvdy5jYWxsKHRoaXMsIGluaXQpO1xuICAgICAgb2JzZXJ2ZXIuYWRkKHNoYWRvd1Jvb3QpO1xuICAgICAgcmV0dXJuIHNoYWRvd1Jvb3Q7XG4gICAgfTtcbiAgICBpZiAocXVlcnkubGVuZ3RoKSBwYXJzZShyb290W1FTQV0ocXVlcnkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgZHJvcDogZHJvcCxcbiAgICAgIGZsdXNoOiBmbHVzaCxcbiAgICAgIG9ic2VydmVyOiBvYnNlcnZlcixcbiAgICAgIHBhcnNlOiBwYXJzZVxuICAgIH07XG4gIH0pO1xuXG4gIHZhciBfc2VsZiA9IHNlbGYsXG4gICAgICBkb2N1bWVudCQxID0gX3NlbGYuZG9jdW1lbnQsXG4gICAgICBNYXAgPSBfc2VsZi5NYXAsXG4gICAgICBNdXRhdGlvbk9ic2VydmVyJDEgPSBfc2VsZi5NdXRhdGlvbk9ic2VydmVyLFxuICAgICAgT2JqZWN0JDEgPSBfc2VsZi5PYmplY3QsXG4gICAgICBTZXQkMSA9IF9zZWxmLlNldCxcbiAgICAgIFdlYWtNYXAgPSBfc2VsZi5XZWFrTWFwLFxuICAgICAgRWxlbWVudCA9IF9zZWxmLkVsZW1lbnQsXG4gICAgICBIVE1MRWxlbWVudCA9IF9zZWxmLkhUTUxFbGVtZW50LFxuICAgICAgTm9kZSA9IF9zZWxmLk5vZGUsXG4gICAgICBFcnJvciA9IF9zZWxmLkVycm9yLFxuICAgICAgVHlwZUVycm9yID0gX3NlbGYuVHlwZUVycm9yLFxuICAgICAgUmVmbGVjdCA9IF9zZWxmLlJlZmxlY3Q7XG4gIHZhciBQcm9taXNlJDEgPSBzZWxmLlByb21pc2UgfHwgTGllO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QkMS5kZWZpbmVQcm9wZXJ0eSxcbiAgICAgIGtleXMgPSBPYmplY3QkMS5rZXlzLFxuICAgICAgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdCQxLmdldE93blByb3BlcnR5TmFtZXMsXG4gICAgICBzZXRQcm90b3R5cGVPZiA9IE9iamVjdCQxLnNldFByb3RvdHlwZU9mO1xuICB2YXIgbGVnYWN5ID0gIXNlbGYuY3VzdG9tRWxlbWVudHM7XG5cbiAgdmFyIGV4cGFuZG8gPSBmdW5jdGlvbiBleHBhbmRvKGVsZW1lbnQpIHtcbiAgICB2YXIga2V5ID0ga2V5cyhlbGVtZW50KTtcbiAgICB2YXIgdmFsdWUgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlW2ldID0gZWxlbWVudFtrZXlbaV1dO1xuICAgICAgZGVsZXRlIGVsZW1lbnRba2V5W2ldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbmd0aDsgX2krKykge1xuICAgICAgICBlbGVtZW50W2tleVtfaV1dID0gdmFsdWVbX2ldO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgaWYgKGxlZ2FjeSkge1xuICAgIHZhciBIVE1MQnVpbHRJbiA9IGZ1bmN0aW9uIEhUTUxCdWlsdEluKCkge1xuICAgICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmICghY2xhc3Nlcy5oYXMoY29uc3RydWN0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICB2YXIgaXMgPSBjbGFzc2VzLmdldChjb25zdHJ1Y3Rvcik7XG4gICAgICBpZiAob3ZlcnJpZGUpIHJldHVybiBhdWdtZW50KG92ZXJyaWRlLCBpcyk7XG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCQxLCBpcyk7XG4gICAgICByZXR1cm4gYXVnbWVudChzZXRQcm90b3R5cGVPZihlbGVtZW50LCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpLCBpcyk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50O1xuICAgIHZhciBjbGFzc2VzID0gbmV3IE1hcCgpO1xuICAgIHZhciBkZWZpbmVkID0gbmV3IE1hcCgpO1xuICAgIHZhciBwcm90b3R5cGVzID0gbmV3IE1hcCgpO1xuICAgIHZhciByZWdpc3RyeSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgcXVlcnkgPSBbXTtcblxuICAgIHZhciBoYW5kbGUgPSBmdW5jdGlvbiBoYW5kbGUoZWxlbWVudCwgY29ubmVjdGVkLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIHByb3RvID0gcHJvdG90eXBlcy5nZXQoc2VsZWN0b3IpO1xuXG4gICAgICBpZiAoY29ubmVjdGVkICYmICFwcm90by5pc1Byb3RvdHlwZU9mKGVsZW1lbnQpKSB7XG4gICAgICAgIHZhciByZWRlZmluZSA9IGV4cGFuZG8oZWxlbWVudCk7XG4gICAgICAgIG92ZXJyaWRlID0gc2V0UHJvdG90eXBlT2YoZWxlbWVudCwgcHJvdG8pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IHByb3RvLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgb3ZlcnJpZGUgPSBudWxsO1xuICAgICAgICAgIHJlZGVmaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1ldGhvZCA9IFwiXCIuY29uY2F0KGNvbm5lY3RlZCA/ICcnIDogJ2RpcycsIFwiY29ubmVjdGVkQ2FsbGJhY2tcIik7XG4gICAgICBpZiAobWV0aG9kIGluIHByb3RvKSBlbGVtZW50W21ldGhvZF0oKTtcbiAgICB9O1xuXG4gICAgdmFyIF9xc2FPYnNlcnZlciA9IHFzYU9ic2VydmVyKHtcbiAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgIGhhbmRsZTogaGFuZGxlXG4gICAgfSksXG4gICAgICAgIHBhcnNlID0gX3FzYU9ic2VydmVyLnBhcnNlO1xuXG4gICAgdmFyIG92ZXJyaWRlID0gbnVsbDtcblxuICAgIHZhciB3aGVuRGVmaW5lZCA9IGZ1bmN0aW9uIHdoZW5EZWZpbmVkKG5hbWUpIHtcbiAgICAgIGlmICghZGVmaW5lZC5oYXMobmFtZSkpIHtcbiAgICAgICAgdmFyIF8sXG4gICAgICAgICAgICAkID0gbmV3IExpZShmdW5jdGlvbiAoJCkge1xuICAgICAgICAgIF8gPSAkO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZWZpbmVkLnNldChuYW1lLCB7XG4gICAgICAgICAgJDogJCxcbiAgICAgICAgICBfOiBfXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmaW5lZC5nZXQobmFtZSkuJDtcbiAgICB9O1xuXG4gICAgdmFyIGF1Z21lbnQgPSBhdHRyaWJ1dGVzT2JzZXJ2ZXIod2hlbkRlZmluZWQsIE11dGF0aW9uT2JzZXJ2ZXIkMSk7XG4gICAgZGVmaW5lUHJvcGVydHkoc2VsZiwgJ2N1c3RvbUVsZW1lbnRzJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgZGVmaW5lOiBmdW5jdGlvbiBkZWZpbmUoaXMsIENsYXNzKSB7XG4gICAgICAgICAgaWYgKHJlZ2lzdHJ5LmhhcyhpcykpIHRocm93IG5ldyBFcnJvcihcInRoZSBuYW1lIFxcXCJcIi5jb25jYXQoaXMsIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgd2l0aCB0aGlzIHJlZ2lzdHJ5XCIpKTtcbiAgICAgICAgICBjbGFzc2VzLnNldChDbGFzcywgaXMpO1xuICAgICAgICAgIHByb3RvdHlwZXMuc2V0KGlzLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgICAgIHJlZ2lzdHJ5LnNldChpcywgQ2xhc3MpO1xuICAgICAgICAgIHF1ZXJ5LnB1c2goaXMpO1xuICAgICAgICAgIHdoZW5EZWZpbmVkKGlzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBhcnNlKGRvY3VtZW50JDEucXVlcnlTZWxlY3RvckFsbChpcykpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVmaW5lZC5nZXQoaXMpLl8oQ2xhc3MpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChpcykge1xuICAgICAgICAgIHJldHVybiByZWdpc3RyeS5nZXQoaXMpO1xuICAgICAgICB9LFxuICAgICAgICB3aGVuRGVmaW5lZDogd2hlbkRlZmluZWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmVQcm9wZXJ0eShIVE1MQnVpbHRJbi5wcm90b3R5cGUgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIHtcbiAgICAgIHZhbHVlOiBIVE1MQnVpbHRJblxuICAgIH0pO1xuICAgIGRlZmluZVByb3BlcnR5KHNlbGYsICdIVE1MRWxlbWVudCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBIVE1MQnVpbHRJblxuICAgIH0pO1xuICAgIGRlZmluZVByb3BlcnR5KGRvY3VtZW50JDEsICdjcmVhdGVFbGVtZW50Jywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGlzID0gb3B0aW9ucyAmJiBvcHRpb25zLmlzO1xuICAgICAgICB2YXIgQ2xhc3MgPSBpcyA/IHJlZ2lzdHJ5LmdldChpcykgOiByZWdpc3RyeS5nZXQobmFtZSk7XG4gICAgICAgIHJldHVybiBDbGFzcyA/IG5ldyBDbGFzcygpIDogY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50JDEsIG5hbWUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBpbiBjYXNlIFNoYWRvd0RPTSBpcyB1c2VkIHRocm91Z2ggYSBwb2x5ZmlsbCwgdG8gYXZvaWQgaXNzdWVzXG4gICAgLy8gd2l0aCBidWlsdGluIGV4dGVuZHMgd2l0aGluIHNoYWRvdyByb290c1xuXG4gICAgaWYgKCEoJ2lzQ29ubmVjdGVkJyBpbiBOb2RlLnByb3RvdHlwZSkpIGRlZmluZVByb3BlcnR5KE5vZGUucHJvdG90eXBlLCAnaXNDb25uZWN0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5vd25lckRvY3VtZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMpICYgdGhpcy5ET0NVTUVOVF9QT1NJVElPTl9ESVNDT05ORUNURUQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICB2YXIgTEkgPSBmdW5jdGlvbiBMSSgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuUmVmbGVjdC5jb25zdHJ1Y3QoSFRNTExJRWxlbWVudCwgW10sIExJKTtcbiAgICAgIH07XG5cbiAgICAgIExJLnByb3RvdHlwZSA9IEhUTUxMSUVsZW1lbnQucHJvdG90eXBlO1xuICAgICAgdmFyIGlzID0gJ2V4dGVuZHMtbGknO1xuICAgICAgc2VsZi5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2V4dGVuZHMtbGknLCBMSSwge1xuICAgICAgICAnZXh0ZW5kcyc6ICdsaSdcbiAgICAgIH0pO1xuICAgICAgbGVnYWN5ID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdsaScsIHtcbiAgICAgICAgaXM6IGlzXG4gICAgICB9KS5vdXRlckhUTUwuaW5kZXhPZihpcykgPCAwO1xuICAgICAgdmFyIF9zZWxmJGN1c3RvbUVsZW1lbnRzID0gc2VsZi5jdXN0b21FbGVtZW50cyxcbiAgICAgICAgICBnZXQgPSBfc2VsZiRjdXN0b21FbGVtZW50cy5nZXQsXG4gICAgICAgICAgX3doZW5EZWZpbmVkID0gX3NlbGYkY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQ7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShzZWxmLmN1c3RvbUVsZW1lbnRzLCAnd2hlbkRlZmluZWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGlzKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgIHJldHVybiBfd2hlbkRlZmluZWQuY2FsbCh0aGlzLCBpcykudGhlbihmdW5jdGlvbiAoQ2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBDbGFzcyB8fCBnZXQuY2FsbChfdGhpcywgaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChvX08pIHtcbiAgICAgIGxlZ2FjeSA9ICFsZWdhY3k7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxlZ2FjeSkge1xuICAgIHZhciBwYXJzZVNoYWRvdyA9IGZ1bmN0aW9uIHBhcnNlU2hhZG93KGVsZW1lbnQpIHtcbiAgICAgIHZhciByb290ID0gc2hhZG93Um9vdHMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBfcGFyc2Uocm9vdC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMpLCBlbGVtZW50LmlzQ29ubmVjdGVkKTtcbiAgICB9O1xuXG4gICAgdmFyIGN1c3RvbUVsZW1lbnRzID0gc2VsZi5jdXN0b21FbGVtZW50cztcbiAgICB2YXIgYXR0YWNoU2hhZG93ID0gRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93O1xuICAgIHZhciBfY3JlYXRlRWxlbWVudCA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudDtcbiAgICB2YXIgZGVmaW5lID0gY3VzdG9tRWxlbWVudHMuZGVmaW5lLFxuICAgICAgICBfZ2V0ID0gY3VzdG9tRWxlbWVudHMuZ2V0O1xuXG4gICAgdmFyIF9yZWYgPSBSZWZsZWN0IHx8IHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBIVE1MRWxlbWVudC5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIGNvbnN0cnVjdCA9IF9yZWYuY29uc3RydWN0O1xuXG4gICAgdmFyIHNoYWRvd1Jvb3RzID0gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgc2hhZG93cyA9IG5ldyBTZXQkMSgpO1xuXG4gICAgdmFyIF9jbGFzc2VzID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIF9kZWZpbmVkID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIF9wcm90b3R5cGVzID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIF9yZWdpc3RyeSA9IG5ldyBNYXAoKTtcblxuICAgIHZhciBzaGFkb3dlZCA9IFtdO1xuICAgIHZhciBfcXVlcnkgPSBbXTtcblxuICAgIHZhciBnZXRDRSA9IGZ1bmN0aW9uIGdldENFKGlzKSB7XG4gICAgICByZXR1cm4gX3JlZ2lzdHJ5LmdldChpcykgfHwgX2dldC5jYWxsKGN1c3RvbUVsZW1lbnRzLCBpcyk7XG4gICAgfTtcblxuICAgIHZhciBfaGFuZGxlID0gZnVuY3Rpb24gX2hhbmRsZShlbGVtZW50LCBjb25uZWN0ZWQsIHNlbGVjdG9yKSB7XG4gICAgICB2YXIgcHJvdG8gPSBfcHJvdG90eXBlcy5nZXQoc2VsZWN0b3IpO1xuXG4gICAgICBpZiAoY29ubmVjdGVkICYmICFwcm90by5pc1Byb3RvdHlwZU9mKGVsZW1lbnQpKSB7XG4gICAgICAgIHZhciByZWRlZmluZSA9IGV4cGFuZG8oZWxlbWVudCk7XG4gICAgICAgIF9vdmVycmlkZSA9IHNldFByb3RvdHlwZU9mKGVsZW1lbnQsIHByb3RvKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBwcm90by5jb25zdHJ1Y3RvcigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9vdmVycmlkZSA9IG51bGw7XG4gICAgICAgICAgcmVkZWZpbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWV0aG9kID0gXCJcIi5jb25jYXQoY29ubmVjdGVkID8gJycgOiAnZGlzJywgXCJjb25uZWN0ZWRDYWxsYmFja1wiKTtcbiAgICAgIGlmIChtZXRob2QgaW4gcHJvdG8pIGVsZW1lbnRbbWV0aG9kXSgpO1xuICAgIH07XG5cbiAgICB2YXIgX3FzYU9ic2VydmVyMiA9IHFzYU9ic2VydmVyKHtcbiAgICAgIHF1ZXJ5OiBfcXVlcnksXG4gICAgICBoYW5kbGU6IF9oYW5kbGVcbiAgICB9KSxcbiAgICAgICAgX3BhcnNlID0gX3FzYU9ic2VydmVyMi5wYXJzZTtcblxuICAgIHZhciBfcXNhT2JzZXJ2ZXIzID0gcXNhT2JzZXJ2ZXIoe1xuICAgICAgcXVlcnk6IHNoYWRvd2VkLFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiBoYW5kbGUoZWxlbWVudCwgY29ubmVjdGVkKSB7XG4gICAgICAgIGlmIChzaGFkb3dSb290cy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICBpZiAoY29ubmVjdGVkKSBzaGFkb3dzLmFkZChlbGVtZW50KTtlbHNlIHNoYWRvd3NbXCJkZWxldGVcIl0oZWxlbWVudCk7XG4gICAgICAgICAgaWYgKF9xdWVyeS5sZW5ndGgpIHBhcnNlU2hhZG93LmNhbGwoX3F1ZXJ5LCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgICAgICBwYXJzZVNoYWRvd2VkID0gX3FzYU9ic2VydmVyMy5wYXJzZTtcblxuICAgIHZhciBfd2hlbkRlZmluZWQyID0gZnVuY3Rpb24gX3doZW5EZWZpbmVkMihuYW1lKSB7XG4gICAgICBpZiAoIV9kZWZpbmVkLmhhcyhuYW1lKSkge1xuICAgICAgICB2YXIgXyxcbiAgICAgICAgICAgICQgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uICgkKSB7XG4gICAgICAgICAgXyA9ICQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9kZWZpbmVkLnNldChuYW1lLCB7XG4gICAgICAgICAgJDogJCxcbiAgICAgICAgICBfOiBfXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2RlZmluZWQuZ2V0KG5hbWUpLiQ7XG4gICAgfTtcblxuICAgIHZhciBfYXVnbWVudCA9IGF0dHJpYnV0ZXNPYnNlcnZlcihfd2hlbkRlZmluZWQyLCBNdXRhdGlvbk9ic2VydmVyJDEpO1xuXG4gICAgdmFyIF9vdmVycmlkZSA9IG51bGw7XG4gICAgZ2V0T3duUHJvcGVydHlOYW1lcyhzZWxmKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgIHJldHVybiAvXkhUTUwvLnRlc3Qoayk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgdmFyIEhUTUxFbGVtZW50ID0gc2VsZltrXTtcblxuICAgICAgZnVuY3Rpb24gSFRNTEJ1aWx0SW4oKSB7XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIGlmICghX2NsYXNzZXMuaGFzKGNvbnN0cnVjdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuXG4gICAgICAgIHZhciBfY2xhc3NlcyRnZXQgPSBfY2xhc3Nlcy5nZXQoY29uc3RydWN0b3IpLFxuICAgICAgICAgICAgaXMgPSBfY2xhc3NlcyRnZXQuaXMsXG4gICAgICAgICAgICB0YWcgPSBfY2xhc3NlcyRnZXQudGFnO1xuXG4gICAgICAgIGlmIChpcykge1xuICAgICAgICAgIGlmIChfb3ZlcnJpZGUpIHJldHVybiBfYXVnbWVudChfb3ZlcnJpZGUsIGlzKTtcblxuICAgICAgICAgIHZhciBlbGVtZW50ID0gX2NyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCQxLCB0YWcpO1xuXG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lzJywgaXMpO1xuICAgICAgICAgIHJldHVybiBfYXVnbWVudChzZXRQcm90b3R5cGVPZihlbGVtZW50LCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpLCBpcyk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gY29uc3RydWN0LmNhbGwodGhpcywgSFRNTEVsZW1lbnQsIFtdLCBjb25zdHJ1Y3Rvcik7XG4gICAgICB9XG5cblxuICAgICAgZGVmaW5lUHJvcGVydHkoSFRNTEJ1aWx0SW4ucHJvdG90eXBlID0gSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnY29uc3RydWN0b3InLCB7XG4gICAgICAgIHZhbHVlOiBIVE1MQnVpbHRJblxuICAgICAgfSk7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShzZWxmLCBrLCB7XG4gICAgICAgIHZhbHVlOiBIVE1MQnVpbHRJblxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQkMSwgJ2NyZWF0ZUVsZW1lbnQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaXMgPSBvcHRpb25zICYmIG9wdGlvbnMuaXM7XG5cbiAgICAgICAgaWYgKGlzKSB7XG4gICAgICAgICAgdmFyIENsYXNzID0gX3JlZ2lzdHJ5LmdldChpcyk7XG5cbiAgICAgICAgICBpZiAoQ2xhc3MgJiYgX2NsYXNzZXMuZ2V0KENsYXNzKS50YWcgPT09IG5hbWUpIHJldHVybiBuZXcgQ2xhc3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0gX2NyZWF0ZUVsZW1lbnQuY2FsbChkb2N1bWVudCQxLCBuYW1lKTtcblxuICAgICAgICBpZiAoaXMpIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpcycsIGlzKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGF0dGFjaFNoYWRvdykgRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93ID0gZnVuY3Rpb24gKGluaXQpIHtcbiAgICAgIHZhciByb290ID0gYXR0YWNoU2hhZG93LmNhbGwodGhpcywgaW5pdCk7XG4gICAgICBzaGFkb3dSb290cy5zZXQodGhpcywgcm9vdCk7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICAgIGRlZmluZVByb3BlcnR5KGN1c3RvbUVsZW1lbnRzLCAnZ2V0Jywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGdldENFXG4gICAgfSk7XG4gICAgZGVmaW5lUHJvcGVydHkoY3VzdG9tRWxlbWVudHMsICd3aGVuRGVmaW5lZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBfd2hlbkRlZmluZWQyXG4gICAgfSk7XG4gICAgZGVmaW5lUHJvcGVydHkoY3VzdG9tRWxlbWVudHMsICdkZWZpbmUnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoaXMsIENsYXNzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChnZXRDRShpcykpIHRocm93IG5ldyBFcnJvcihcIidcIi5jb25jYXQoaXMsIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBjdXN0b20gZWxlbWVudFwiKSk7XG4gICAgICAgIHZhciBzZWxlY3RvcjtcbiAgICAgICAgdmFyIHRhZyA9IG9wdGlvbnMgJiYgb3B0aW9uc1tcImV4dGVuZHNcIl07XG5cbiAgICAgICAgX2NsYXNzZXMuc2V0KENsYXNzLCB0YWcgPyB7XG4gICAgICAgICAgaXM6IGlzLFxuICAgICAgICAgIHRhZzogdGFnXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgaXM6ICcnLFxuICAgICAgICAgIHRhZzogaXNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgIHNlbGVjdG9yID0gXCJcIi5jb25jYXQodGFnLCBcIltpcz1cXFwiXCIpLmNvbmNhdChpcywgXCJcXFwiXVwiKTtcblxuICAgICAgICAgIF9wcm90b3R5cGVzLnNldChzZWxlY3RvciwgQ2xhc3MucHJvdG90eXBlKTtcblxuICAgICAgICAgIF9yZWdpc3RyeS5zZXQoaXMsIENsYXNzKTtcblxuICAgICAgICAgIF9xdWVyeS5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZpbmUuYXBwbHkoY3VzdG9tRWxlbWVudHMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgc2hhZG93ZWQucHVzaChzZWxlY3RvciA9IGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF93aGVuRGVmaW5lZDIoaXMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIF9wYXJzZShkb2N1bWVudCQxLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcblxuICAgICAgICAgICAgc2hhZG93cy5mb3JFYWNoKHBhcnNlU2hhZG93LCBbc2VsZWN0b3JdKTtcbiAgICAgICAgICB9IGVsc2UgcGFyc2VTaGFkb3dlZChkb2N1bWVudCQxLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2RlZmluZWQuZ2V0KGlzKS5fKENsYXNzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9